        let aiAction;
        try {
          const cleaned = (response as string).replace(/[\n\r]+/g, ' ');
          aiAction = JSON.parse(cleaned);
        } catch (e) {
          aiAction = { action: "reply", text: response };
        }

        const passed = aiAction.action === args.expectedAction;

        return {
          success: true,
          passed,
          scenario: args.testScenario,
          userMessage: args.userMessage,
          expectedAction: args.expectedAction,
          actualAction: aiAction.action,
          aiResponse: aiAction,
        };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : "Unknown error",
          scenario: args.testScenario,
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        scenario: args.testScenario,
      };
    }
  },
});

export const testModelPerformance = action({
  args: {
    testPrompt: v.string(),
    expectedKeywords: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    try {
      const startTime = Date.now();
      
      const response = await ctx.runAction(api.ai.generate, {
        prompt: args.testPrompt,
        systemPrompt: "You are a helpful assistant. Provide concise, accurate responses.",
      });

      const endTime = Date.now();
      const responseTime = endTime - startTime;

      // Check if response contains expected keywords
      const foundKeywords = args.expectedKeywords.filter(keyword => 
        (response as string).toLowerCase().includes(keyword.toLowerCase())
      );

      const keywordScore = foundKeywords.length / args.expectedKeywords.length;
      const passed = keywordScore >= 0.5; // At least 50% of keywords found

      return {
        success: true,
        passed,
        responseTime,
        keywordScore: `${(keywordScore * 100).toFixed(1)}%`,
        foundKeywords,
        missedKeywords: args.expectedKeywords.filter(k => !foundKeywords.includes(k)),
        responseLength: (response as string).length,
        response: (response as string).substring(0, 200),
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  },
});

export const testApiUsageTracking = action({
  args: {},
  handler: async (ctx) => {
    try {
      // Get current API key usage stats
      const keys = await ctx.runQuery(api.geminiMutations.getGeminiApiKeys, {
        adminId: "test_admin" as any,
      });

      const usageStats = keys.map((key: any) => ({
        label: key.label || "Unlabeled",
        isActive: key.isActive,
        usageCount: key.usageCount,
        lastUsedAt: key.lastUsedAt,
        lastResetAt: key.lastResetAt,
      }));

      // Test a simple AI call to verify tracking
      await ctx.runAction(api.ai.generate, {
        prompt: "Hello, this is a test.",
        systemPrompt: "Respond with 'Test successful'",
      });

      return {
        success: true,
        usageStats,
        message: "Usage tracking verified. Check that usageCount incremented.",
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  },
});

export const runComprehensiveTests = action({
  args: {},
  handler: async (ctx) => {
    const results: any[] = [];

    // WhatsApp AI Flow Tests
    const whatsappTests = [
      {
        scenario: "Product inquiry",
        message: "Tell me about VAONOPULSE",
        expectedAction: "reply",
      },
      {
        scenario: "Request product image",
        message: "Show me a picture of VAONOPULSE",
        expectedAction: "send_image",
      },
      {
        scenario: "Request PDF",
        message: "Send me the product catalog",
        expectedAction: "send_pdf",
      },
      {
        scenario: "Contact request",
        message: "I want to speak with a sales representative",
        expectedAction: "contact_request",
      },
      {
        scenario: "Intervention needed",
        message: "I have a complex technical question",
        expectedAction: "intervention_request",
      },
    ];

    for (const test of whatsappTests) {
      try {
        const result = await ctx.runAction(api.test_ai_comprehensive.testWhatsAppAiFlow, test);
        results.push({ type: "whatsapp_ai", ...result });
      } catch (error) {
        results.push({
          type: "whatsapp_ai",
          success: false,
          scenario: test.scenario,
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    }

    // Model Performance Tests
    const performanceTests = [
      {
        prompt: "What are the benefits of pharmaceutical CRM systems?",
        keywords: ["crm", "pharmaceutical", "benefits", "management"],
      },
      {
        prompt: "Explain lead qualification in sales",
        keywords: ["lead", "qualification", "sales", "process"],
      },
    ];

    for (const test of performanceTests) {
      try {
        const result = await ctx.runAction(api.test_ai_comprehensive.testModelPerformance, {
          testPrompt: test.prompt,
          expectedKeywords: test.keywords,
        });
        results.push({ type: "model_performance", ...result });
      } catch (error) {
        results.push({
          type: "model_performance",
          success: false,
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    }

    // API Usage Tracking Test
    try {
      const usageResult = await ctx.runAction(api.test_ai_comprehensive.testApiUsageTracking);
      results.push({ type: "usage_tracking", ...usageResult });
    } catch (error) {
      results.push({
        type: "usage_tracking",
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }

    const totalTests = results.length;
    const passedTests = results.filter((r: any) => r.passed || r.success).length;
    const failedTests = totalTests - passedTests;

    return {
      summary: {
        total: totalTests,
        passed: passedTests,
        failed: failedTests,
        successRate: `${((passedTests / totalTests) * 100).toFixed(1)}%`,
        timestamp: new Date().toISOString(),
      },
      results,
    };
  },
});