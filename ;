  const match = text.match(jsonBlockRegex);
  if (match && match[1]) {
    return match[1].trim();
  }
  // fallback: return entire text if no code block found
  return text;
}

export const generateAndSendAiReply = action({
  args: {
    leadId: v.id("leads"),
    phoneNumber: v.string(),
    prompt: v.string(),
    context: v.any(),
    userId: v.optional(v.id("users")),
    replyingToMessageId: v.optional(v.id("messages")),
    replyingToExternalId: v.optional(v.string()),
    isAutoReply: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    // Fetch keys from DB
    // @ts-ignore
    const keys = await ctx.runMutation(internal.geminiMutations.getActiveKeys) as Doc<"geminiApiKeys">[];
    
    // Combine DB keys with env var key if available
    const allKeys: Array<{ apiKey: string; keyId?: Id<"geminiApiKeys">; label?: string }> = [...keys];
    
    if (process.env.GEMINI_API_KEY || process.env.GOOGLE_API_KEY) {
      allKeys.push({ 
        apiKey: (process.env.GEMINI_API_KEY || process.env.GOOGLE_API_KEY)!, 
        label: "Env Key" 
      });
    }

    if (allKeys.length === 0) {
      console.error("No Gemini API keys configured for WhatsApp AI.");
      return;
    }

    // Fetch available resources for context
    const products = await ctx.runQuery(api.products.listProducts);
    const rangePdfs = await ctx.runQuery(api.rangePdfs.listRangePdfs);

    const productNames = products.map((p: any) => p.name).join(", ");
    const pdfNames = rangePdfs.map((p: any) => p.name).join(", ");

    const modelsToTry = [
      "gemini-3-flash", 
      "gemini-2.5-flash-lite",
      "gemini-2.5-flash",
      "gemini-2.0-flash",
      "gemini-1.5-flash"
    ];

    let success = false;
    let generatedText = "";

    // Try models sequentially
    for (const modelName of modelsToTry) {
      // For each model, try all available keys
      for (const key of allKeys) {
        try {
          const genAI = new GoogleGenerativeAI(key.apiKey);
          const model = genAI.getGenerativeModel({ model: modelName });

          const systemPrompt = `You are a helpful CRM assistant for a pharmaceutical company.
          You are chatting with a lead on WhatsApp.
          
          Available Products: ${productNames}
          Available Range PDFs: ${pdfNames}
          
          Your goal is to assist the lead, answer questions, and provide product information.
          
          You can perform the following actions by returning a JSON object:
          1. Reply with text: { "action": "reply", "text": "your message" }
          2. Send a product image: { "action": "send_image", "text": "optional caption", "resource_name": "exact product name" }
          3. Send a PDF: { "action": "send_pdf", "text": "optional caption", "resource_name": "exact pdf name" }
          4. Request human intervention (if you can't help): { "action": "intervention_request", "text": "I will connect you with an agent.", "reason": "reason" }
          5. Request contact (if they want a meeting/call): { "action": "contact_request", "text": "I've noted your request.", "reason": "reason" }
          
          Always return ONLY the JSON object. Do not include other text.
          `;

          const chatContext = JSON.stringify(args.context);
          const userPrompt = `Context: ${chatContext}\n\nUser Message: ${args.prompt}`;

          console.log(`Attempting to generate WhatsApp reply with model: ${modelName} using key: ${key.label || "..."}`);
          const result = await model.generateContent([systemPrompt, userPrompt]);
          const response = result.response;
          generatedText = response.text();

          // Increment usage if we used a DB key
          if (key.keyId) {
            // @ts-ignore
            await ctx.runMutation(internal.geminiMutations.incrementUsage, { keyId: key.keyId });
          }

          success = true;
          console.log(`Successfully generated WhatsApp reply with model: ${modelName}`);
          break; // Exit key loop
        } catch (error) {
          console.warn(`Model ${modelName} failed with key ${key.label || "..."}:`, error);
          // Continue to next key
        }
      }
      if (success) break; // Exit model loop
    }

    if (!success) {
      console.error("All Gemini API keys and models failed for WhatsApp AI.");
      await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
          leadId: args.leadId,
          phoneNumber: args.phoneNumber,
          message: "I'm having trouble processing your request right now. Please try again later.",
      });
      return;
    }
      
    const jsonStr = extractJsonFromMarkdown(generatedText);
    let aiAction;
    try {
      aiAction = JSON.parse(jsonStr);
    } catch (e) {
      console.error("Failed to parse AI response as JSON", generatedText);
      // Fallback to text reply
      aiAction = { action: "reply", text: generatedText };
    }

    console.log("AI Action:", aiAction);

    // Execute Action
    try {
      if (aiAction.action === "reply") {
        await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
          leadId: args.leadId,
          phoneNumber: args.phoneNumber,
          message: aiAction.text,
          quotedMessageId: args.replyingToMessageId,
          quotedMessageExternalId: args.replyingToExternalId,
        });
      } else if (aiAction.action === "send_image") {
        const product = products.find((p: any) => p.name === aiAction.resource_name);
        if (product && product.images && product.images.length > 0) {
           const storageId = product.images[0];
           // Get metadata for mime type
           const metadata = await ctx.runQuery(internal.products.getStorageMetadata, { storageId });
           
           await ctx.runAction(api.whatsapp.sendWhatsAppMedia, {
             leadId: args.leadId,
             phoneNumber: args.phoneNumber,
             storageId: storageId,
             fileName: `${product.name}.jpg`, 
             mimeType: metadata?.contentType || "image/jpeg",
             message: aiAction.text
           });
        } else {
           await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
             leadId: args.leadId,
             phoneNumber: args.phoneNumber,
             message: `I couldn't find the image for ${aiAction.resource_name}. ${aiAction.text}`,
           });
        }
      } else if (aiAction.action === "send_pdf") {
         const pdf = rangePdfs.find((p: any) => p.name === aiAction.resource_name);
         if (pdf) {
           const metadata = await ctx.runQuery(internal.products.getStorageMetadata, { storageId: pdf.storageId });
           
           await ctx.runAction(api.whatsapp.sendWhatsAppMedia, {
             leadId: args.leadId,
             phoneNumber: args.phoneNumber,
             storageId: pdf.storageId,
             fileName: `${pdf.name}.pdf`,
             mimeType: metadata?.contentType || "application/pdf",
             message: aiAction.text
           });
         } else {
            await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
             leadId: args.leadId,
             phoneNumber: args.phoneNumber,
             message: `I couldn't find the PDF for ${aiAction.resource_name}. ${aiAction.text}`,
           });
         }
      } else if (aiAction.action === "intervention_request") {
          await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
            leadId: args.leadId,
            phoneNumber: args.phoneNumber,
            message: aiAction.text,
          });
          // Try to create intervention request if module exists
          try {
            // @ts-ignore
            if (api.interventionRequests && api.interventionRequests.create) {
                // @ts-ignore
                await ctx.runMutation(api.interventionRequests.create, { 
                    leadId: args.leadId, 
                    reason: aiAction.reason || "AI Request",
                    status: "pending"
                });
            }
          } catch (e) {
              console.error("Failed to create intervention request", e);
          }
      } else if (aiAction.action === "contact_request") {
          await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
            leadId: args.leadId,
            phoneNumber: args.phoneNumber,
            message: aiAction.text,
          });
          // Try to create contact request if module exists
          try {
            // @ts-ignore
            if (api.contactRequests && api.contactRequests.create) {
                // @ts-ignore
                await ctx.runMutation(api.contactRequests.create, { 
                    leadId: args.leadId, 
                    type: "general",
                    status: "pending",
                    notes: aiAction.reason
                });
            }
          } catch (e) {
              console.error("Failed to create contact request", e);
          }
      }
    } catch (error) {
      console.error("Error executing AI action:", error);
      await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
          leadId: args.leadId,
          phoneNumber: args.phoneNumber,
          message: "I encountered an error while trying to perform that action.",
      });
    }
  }
});
